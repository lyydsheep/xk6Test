// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package dao

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"email/dal/model"
)

func newOpsEmlNumberSuccess(db *gorm.DB, opts ...gen.DOOption) opsEmlNumberSuccess {
	_opsEmlNumberSuccess := opsEmlNumberSuccess{}

	_opsEmlNumberSuccess.opsEmlNumberSuccessDo.UseDB(db, opts...)
	_opsEmlNumberSuccess.opsEmlNumberSuccessDo.UseModel(&model.OpsEmlNumberSuccess{})

	tableName := _opsEmlNumberSuccess.opsEmlNumberSuccessDo.TableName()
	_opsEmlNumberSuccess.ALL = field.NewAsterisk(tableName)
	_opsEmlNumberSuccess.ID = field.NewInt64(tableName, "id")
	_opsEmlNumberSuccess.Cid = field.NewInt64(tableName, "cid")
	_opsEmlNumberSuccess.FromAddress = field.NewString(tableName, "from_address")
	_opsEmlNumberSuccess.Domain = field.NewString(tableName, "domain")
	_opsEmlNumberSuccess.StartTime = field.NewTime(tableName, "start_time")
	_opsEmlNumberSuccess.EndTime = field.NewTime(tableName, "end_time")
	_opsEmlNumberSuccess.SuccessCnt = field.NewInt32(tableName, "success_cnt")
	_opsEmlNumberSuccess.TemporaryErr = field.NewInt32(tableName, "temporary_err")
	_opsEmlNumberSuccess.PermanentErr = field.NewInt32(tableName, "permanent_err")
	_opsEmlNumberSuccess.TotalCnt = field.NewInt32(tableName, "total_cnt")
	_opsEmlNumberSuccess.CreateTime = field.NewTime(tableName, "create_time")
	_opsEmlNumberSuccess.UpdateTime = field.NewTime(tableName, "update_time")

	_opsEmlNumberSuccess.fillFieldMap()

	return _opsEmlNumberSuccess
}

type opsEmlNumberSuccess struct {
	opsEmlNumberSuccessDo opsEmlNumberSuccessDo

	ALL          field.Asterisk
	ID           field.Int64
	Cid          field.Int64
	FromAddress  field.String // 发件人邮箱
	Domain       field.String // 收件域
	StartTime    field.Time   // 区间开始时间
	EndTime      field.Time   // 区间结束时间
	SuccessCnt   field.Int32  // 成功发送数量
	TemporaryErr field.Int32  // 临时错误（可重试）
	PermanentErr field.Int32  // 永久错误（不可重试）
	TotalCnt     field.Int32  // 总发送数量
	CreateTime   field.Time
	UpdateTime   field.Time

	fieldMap map[string]field.Expr
}

func (o opsEmlNumberSuccess) Table(newTableName string) *opsEmlNumberSuccess {
	o.opsEmlNumberSuccessDo.UseTable(newTableName)
	return o.updateTableName(newTableName)
}

func (o opsEmlNumberSuccess) As(alias string) *opsEmlNumberSuccess {
	o.opsEmlNumberSuccessDo.DO = *(o.opsEmlNumberSuccessDo.As(alias).(*gen.DO))
	return o.updateTableName(alias)
}

func (o *opsEmlNumberSuccess) updateTableName(table string) *opsEmlNumberSuccess {
	o.ALL = field.NewAsterisk(table)
	o.ID = field.NewInt64(table, "id")
	o.Cid = field.NewInt64(table, "cid")
	o.FromAddress = field.NewString(table, "from_address")
	o.Domain = field.NewString(table, "domain")
	o.StartTime = field.NewTime(table, "start_time")
	o.EndTime = field.NewTime(table, "end_time")
	o.SuccessCnt = field.NewInt32(table, "success_cnt")
	o.TemporaryErr = field.NewInt32(table, "temporary_err")
	o.PermanentErr = field.NewInt32(table, "permanent_err")
	o.TotalCnt = field.NewInt32(table, "total_cnt")
	o.CreateTime = field.NewTime(table, "create_time")
	o.UpdateTime = field.NewTime(table, "update_time")

	o.fillFieldMap()

	return o
}

func (o *opsEmlNumberSuccess) WithContext(ctx context.Context) *opsEmlNumberSuccessDo {
	return o.opsEmlNumberSuccessDo.WithContext(ctx)
}

func (o opsEmlNumberSuccess) TableName() string { return o.opsEmlNumberSuccessDo.TableName() }

func (o opsEmlNumberSuccess) Alias() string { return o.opsEmlNumberSuccessDo.Alias() }

func (o opsEmlNumberSuccess) Columns(cols ...field.Expr) gen.Columns {
	return o.opsEmlNumberSuccessDo.Columns(cols...)
}

func (o *opsEmlNumberSuccess) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := o.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (o *opsEmlNumberSuccess) fillFieldMap() {
	o.fieldMap = make(map[string]field.Expr, 12)
	o.fieldMap["id"] = o.ID
	o.fieldMap["cid"] = o.Cid
	o.fieldMap["from_address"] = o.FromAddress
	o.fieldMap["domain"] = o.Domain
	o.fieldMap["start_time"] = o.StartTime
	o.fieldMap["end_time"] = o.EndTime
	o.fieldMap["success_cnt"] = o.SuccessCnt
	o.fieldMap["temporary_err"] = o.TemporaryErr
	o.fieldMap["permanent_err"] = o.PermanentErr
	o.fieldMap["total_cnt"] = o.TotalCnt
	o.fieldMap["create_time"] = o.CreateTime
	o.fieldMap["update_time"] = o.UpdateTime
}

func (o opsEmlNumberSuccess) clone(db *gorm.DB) opsEmlNumberSuccess {
	o.opsEmlNumberSuccessDo.ReplaceConnPool(db.Statement.ConnPool)
	return o
}

func (o opsEmlNumberSuccess) replaceDB(db *gorm.DB) opsEmlNumberSuccess {
	o.opsEmlNumberSuccessDo.ReplaceDB(db)
	return o
}

type opsEmlNumberSuccessDo struct{ gen.DO }

func (o opsEmlNumberSuccessDo) Debug() *opsEmlNumberSuccessDo {
	return o.withDO(o.DO.Debug())
}

func (o opsEmlNumberSuccessDo) WithContext(ctx context.Context) *opsEmlNumberSuccessDo {
	return o.withDO(o.DO.WithContext(ctx))
}

func (o opsEmlNumberSuccessDo) ReadDB() *opsEmlNumberSuccessDo {
	return o.Clauses(dbresolver.Read)
}

func (o opsEmlNumberSuccessDo) WriteDB() *opsEmlNumberSuccessDo {
	return o.Clauses(dbresolver.Write)
}

func (o opsEmlNumberSuccessDo) Session(config *gorm.Session) *opsEmlNumberSuccessDo {
	return o.withDO(o.DO.Session(config))
}

func (o opsEmlNumberSuccessDo) Clauses(conds ...clause.Expression) *opsEmlNumberSuccessDo {
	return o.withDO(o.DO.Clauses(conds...))
}

func (o opsEmlNumberSuccessDo) Returning(value interface{}, columns ...string) *opsEmlNumberSuccessDo {
	return o.withDO(o.DO.Returning(value, columns...))
}

func (o opsEmlNumberSuccessDo) Not(conds ...gen.Condition) *opsEmlNumberSuccessDo {
	return o.withDO(o.DO.Not(conds...))
}

func (o opsEmlNumberSuccessDo) Or(conds ...gen.Condition) *opsEmlNumberSuccessDo {
	return o.withDO(o.DO.Or(conds...))
}

func (o opsEmlNumberSuccessDo) Select(conds ...field.Expr) *opsEmlNumberSuccessDo {
	return o.withDO(o.DO.Select(conds...))
}

func (o opsEmlNumberSuccessDo) Where(conds ...gen.Condition) *opsEmlNumberSuccessDo {
	return o.withDO(o.DO.Where(conds...))
}

func (o opsEmlNumberSuccessDo) Order(conds ...field.Expr) *opsEmlNumberSuccessDo {
	return o.withDO(o.DO.Order(conds...))
}

func (o opsEmlNumberSuccessDo) Distinct(cols ...field.Expr) *opsEmlNumberSuccessDo {
	return o.withDO(o.DO.Distinct(cols...))
}

func (o opsEmlNumberSuccessDo) Omit(cols ...field.Expr) *opsEmlNumberSuccessDo {
	return o.withDO(o.DO.Omit(cols...))
}

func (o opsEmlNumberSuccessDo) Join(table schema.Tabler, on ...field.Expr) *opsEmlNumberSuccessDo {
	return o.withDO(o.DO.Join(table, on...))
}

func (o opsEmlNumberSuccessDo) LeftJoin(table schema.Tabler, on ...field.Expr) *opsEmlNumberSuccessDo {
	return o.withDO(o.DO.LeftJoin(table, on...))
}

func (o opsEmlNumberSuccessDo) RightJoin(table schema.Tabler, on ...field.Expr) *opsEmlNumberSuccessDo {
	return o.withDO(o.DO.RightJoin(table, on...))
}

func (o opsEmlNumberSuccessDo) Group(cols ...field.Expr) *opsEmlNumberSuccessDo {
	return o.withDO(o.DO.Group(cols...))
}

func (o opsEmlNumberSuccessDo) Having(conds ...gen.Condition) *opsEmlNumberSuccessDo {
	return o.withDO(o.DO.Having(conds...))
}

func (o opsEmlNumberSuccessDo) Limit(limit int) *opsEmlNumberSuccessDo {
	return o.withDO(o.DO.Limit(limit))
}

func (o opsEmlNumberSuccessDo) Offset(offset int) *opsEmlNumberSuccessDo {
	return o.withDO(o.DO.Offset(offset))
}

func (o opsEmlNumberSuccessDo) Scopes(funcs ...func(gen.Dao) gen.Dao) *opsEmlNumberSuccessDo {
	return o.withDO(o.DO.Scopes(funcs...))
}

func (o opsEmlNumberSuccessDo) Unscoped() *opsEmlNumberSuccessDo {
	return o.withDO(o.DO.Unscoped())
}

func (o opsEmlNumberSuccessDo) Create(values ...*model.OpsEmlNumberSuccess) error {
	if len(values) == 0 {
		return nil
	}
	return o.DO.Create(values)
}

func (o opsEmlNumberSuccessDo) CreateInBatches(values []*model.OpsEmlNumberSuccess, batchSize int) error {
	return o.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (o opsEmlNumberSuccessDo) Save(values ...*model.OpsEmlNumberSuccess) error {
	if len(values) == 0 {
		return nil
	}
	return o.DO.Save(values)
}

func (o opsEmlNumberSuccessDo) First() (*model.OpsEmlNumberSuccess, error) {
	if result, err := o.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.OpsEmlNumberSuccess), nil
	}
}

func (o opsEmlNumberSuccessDo) Take() (*model.OpsEmlNumberSuccess, error) {
	if result, err := o.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.OpsEmlNumberSuccess), nil
	}
}

func (o opsEmlNumberSuccessDo) Last() (*model.OpsEmlNumberSuccess, error) {
	if result, err := o.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.OpsEmlNumberSuccess), nil
	}
}

func (o opsEmlNumberSuccessDo) Find() ([]*model.OpsEmlNumberSuccess, error) {
	result, err := o.DO.Find()
	return result.([]*model.OpsEmlNumberSuccess), err
}

func (o opsEmlNumberSuccessDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.OpsEmlNumberSuccess, err error) {
	buf := make([]*model.OpsEmlNumberSuccess, 0, batchSize)
	err = o.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (o opsEmlNumberSuccessDo) FindInBatches(result *[]*model.OpsEmlNumberSuccess, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return o.DO.FindInBatches(result, batchSize, fc)
}

func (o opsEmlNumberSuccessDo) Attrs(attrs ...field.AssignExpr) *opsEmlNumberSuccessDo {
	return o.withDO(o.DO.Attrs(attrs...))
}

func (o opsEmlNumberSuccessDo) Assign(attrs ...field.AssignExpr) *opsEmlNumberSuccessDo {
	return o.withDO(o.DO.Assign(attrs...))
}

func (o opsEmlNumberSuccessDo) Joins(fields ...field.RelationField) *opsEmlNumberSuccessDo {
	for _, _f := range fields {
		o = *o.withDO(o.DO.Joins(_f))
	}
	return &o
}

func (o opsEmlNumberSuccessDo) Preload(fields ...field.RelationField) *opsEmlNumberSuccessDo {
	for _, _f := range fields {
		o = *o.withDO(o.DO.Preload(_f))
	}
	return &o
}

func (o opsEmlNumberSuccessDo) FirstOrInit() (*model.OpsEmlNumberSuccess, error) {
	if result, err := o.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.OpsEmlNumberSuccess), nil
	}
}

func (o opsEmlNumberSuccessDo) FirstOrCreate() (*model.OpsEmlNumberSuccess, error) {
	if result, err := o.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.OpsEmlNumberSuccess), nil
	}
}

func (o opsEmlNumberSuccessDo) FindByPage(offset int, limit int) (result []*model.OpsEmlNumberSuccess, count int64, err error) {
	result, err = o.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = o.Offset(-1).Limit(-1).Count()
	return
}

func (o opsEmlNumberSuccessDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = o.Count()
	if err != nil {
		return
	}

	err = o.Offset(offset).Limit(limit).Scan(result)
	return
}

func (o opsEmlNumberSuccessDo) Scan(result interface{}) (err error) {
	return o.DO.Scan(result)
}

func (o opsEmlNumberSuccessDo) Delete(models ...*model.OpsEmlNumberSuccess) (result gen.ResultInfo, err error) {
	return o.DO.Delete(models)
}

func (o *opsEmlNumberSuccessDo) withDO(do gen.Dao) *opsEmlNumberSuccessDo {
	o.DO = *do.(*gen.DO)
	return o
}
